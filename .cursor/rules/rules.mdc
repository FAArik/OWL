---
description: "Dynamic AI coding assistant with MANDATORY MCP tool usage"
globs: ["**/*"]
alwaysApply: true
---
# Cursor AI Assistant Rules - Dynamic System

## MANDATORY: READ THESE RULES FIRST!

**CRITICAL INSTRUCTION**: You MUST read and understand these rules completely before responding to any user request. These rules are MANDATORY and must be followed strictly.

## MCP TOOL ACTIVATION PROTOCOL - ABSOLUTELY MANDATORY

**🚨 BEFORE EVERY SINGLE RESPONSE**: Claude MUST verify and use MCP tools!

### MANDATORY STARTUP VERIFICATION
Every response must begin with:
1. **TOOL CHECK**: "🔧 Checking my available MCP tools..."
2. **TOOL LIST**: Explicitly list detected MCP tools
3. **TOOL USAGE**: Use appropriate tools for the task
4. **NEVER SKIP**: If tools aren't working, explicitly state this

### ACTIVE MCP SERVERS - MUST USE THESE

#### mcp-sequentialthinking-tools (PRIORITY 1)
**Available Tool**: `sequentialthinking_tools`
- **MANDATORY USE** for ANY complex problem-solving
- **REQUIRED** for multi-step tasks
- **ESSENTIAL** for debugging and systematic analysis
- **USAGE TRIGGER**: Any task with more than 1 step

#### context7 (PRIORITY 2)
**Available Tools**:
- `resolve-library-id` - Library identification and resolution
- `get-library-docs` - Documentation retrieval
- **MANDATORY USE** for ANY library questions
- **REQUIRED** before implementing third-party code
- **ESSENTIAL** for documentation lookup

### MCP FAILURE PROTOCOL
If MCP tools are not working:
1. **EXPLICITLY STATE**: "⚠️ MCP tools are not responding"
2. **REQUEST ACTION**: Ask user to refresh Cursor MCP settings
3. **SUGGEST RESTART**: Recommend Cursor restart
4. **NEVER PROCEED**: Don't do manual work if MCPs should handle it

## MANDATORY MCP USAGE RULES

**ABSOLUTE REQUIREMENTS**:
- ✅ **EVERY** complex task → `sequentialthinking_tools`
- ✅ **ANY** library question → context7 tools
- ✅ **ALL** multi-step problems → `sequentialthinking_tools`
- ✅ **ANY** documentation need → `get-library-docs`
- ❌ **NEVER** skip MCP when available
- ❌ **NEVER** do manual work that MCP can handle

### FORCED MCP ACTIVATION PHRASES
When user says:
- "explain", "how to", "step by step" → **MUST USE** `sequentialthinking_tools`
- "library", "package", "framework" → **MUST USE** context7 tools
- "documentation", "docs", "API" → **MUST USE** `get-library-docs`
- "analyze", "break down", "solve" → **MUST USE** `sequentialthinking_tools`

## Core Configuration

```yaml
description: "Dynamic AI coding assistant with MANDATORY MCP tool usage"
globs: ["**/*"]
alwaysApply: true
```

## IMPORT MANAGEMENT RULE - COMPREHENSIVE SYSTEM

**MANDATORY**: Advanced import management to prevent unused imports and synchronization issues:

### CORE IMPORT PRINCIPLES
- **NO SPECULATIVE IMPORTS**: NEVER add imports "just in case" or for future use
- **IMPLEMENTATION-DRIVEN IMPORTS**: Only add imports when you are actively writing code that uses them
- **ONE-TO-ONE RELATIONSHIP**: Each import must have corresponding implementation in the same edit
- **COMPLETE IMPLEMENTATION FIRST**: Never add imports without immediately implementing their usage

### IMPORT AUDIT PROTOCOL (MANDATORY BEFORE EVERY EDIT)
**BEFORE making ANY changes to a file:**
1. **SCAN EXISTING IMPORTS**: Check what's already imported
2. **IDENTIFY USAGE**: Verify which imports are actually used in current code
3. **DETECT DUPLICATES**: Look for similar imports (e.g., multiple icon imports)
4. **PLAN CONSOLIDATION**: Group related imports together
5. **MARK FOR CLEANUP**: Note unused imports for potential removal

### IMPORT SYNCHRONIZATION RULES
**When adding new functionality:**
- ✅ **FIRST**: Check if needed functionality is already imported
- ✅ **REUSE**: Use existing imports when possible
- ✅ **CONSOLIDATE**: Group similar imports (e.g., all lucide-react icons in one line)
- ✅ **UPDATE**: Modify existing import statements rather than adding new ones
- ❌ **NEVER**: Add duplicate or similar imports
- ❌ **NEVER**: Leave old imports when replacing functionality

### UNUSED IMPORT DETECTION SYSTEM
**MANDATORY checks in every response:**
- 🔍 **AUTO-SCAN**: Automatically identify unused imports
- 🔍 **CROSS-REFERENCE**: Match imports with actual usage in code
- 🔍 **REPORT STATUS**: Always mention unused imports found
- 🔍 **ASK PERMISSION**: "Found unused imports: X, Y, Z. Should I clean them up?"

### IMPORT CLEANUP PROTOCOLS

#### AUTOMATIC CLEANUP (When Safe):
- Remove imports when replacing entire functionality
- Remove duplicate imports immediately
- Consolidate similar imports (e.g., multiple icons from same library)

#### PERMISSION-BASED CLEANUP:
- **ASK FIRST** before removing potentially useful imports
- **EXPLAIN REASONING**: Why specific imports seem unused
- **OFFER OPTIONS**: "Should I remove unused imports or implement missing functionality?"

### IMPORT-IMPLEMENTATION CYCLE
For every import you add:
1. **WRITE IMPLEMENTATION**: Code the actual functionality first
2. **ADD MINIMAL IMPORTS**: Only import exactly what the implementation uses
3. **VERIFY USAGE**: Ensure every import has corresponding code
4. **CLEAN REDUNDANT**: Remove or update conflicting imports
5. **DOCUMENT CHANGES**: Mention import changes in response

### SPECIAL CASES HANDLING

#### WHEN USER ASKS TO FILL IMPLEMENTATION:
- **DO NOT** remove existing imports
- **DO IMPLEMENT** missing functionality that uses those imports
- **ASK CLARIFICATION**: If imports seem unrelated to request

#### WHEN REFACTORING CODE:
- **UPDATE IMPORTS**: Synchronize with new implementation
- **REMOVE OBSOLETE**: Clean up imports from old implementation
- **CONSOLIDATE**: Group related imports efficiently

#### WHEN ADDING FEATURES:
- **CHECK FIRST**: What's already available in imports
- **EXTEND EXISTING**: Modify current import statements
- **GROUP LOGICALLY**: Keep related imports together

### IMPORT ORGANIZATION STANDARDS
- **GROUP BY SOURCE**: External packages, then internal modules
- **ALPHABETIZE**: Within groups, maintain alphabetical order  
- **CONSOLIDATE**: Multiple imports from same source in one statement
- **TYPE IMPORTS**: Separate type imports when using TypeScript

### ERROR PREVENTION RULES
- **CONSERVATIVE APPROACH**: When in doubt, don't add the import
- **VERIFICATION REQUIRED**: Every import must have visible usage
- **NO ORPHANED IMPORTS**: Never leave imports without implementation
- **SYNCHRONIZATION CHECK**: Ensure imports match current implementation

### IMPORT STATUS REPORTING
**In every response involving imports, include:**
- 📝 "Import changes made: [list]"
- 🧹 "Unused imports detected: [list] - cleaned up/left for user decision"
- 🔄 "Import consolidation: [details]"
- ✅ "All imports verified and synchronized"

## FILE ORGANIZATION AND MODULARITY RULES

**MANDATORY**: Follow proper file organization principles:
- **NEVER** try to implement everything in a single file
- **ALWAYS** create separate files for different concerns:
  - Components in separate files
  - Types/interfaces in dedicated type files
  - Utilities in utility files
  - Constants in constants files
  - Styles in separate CSS/SCSS files
- **CREATE** appropriate folder structure:
  - `/components` for React components
  - `/types` for TypeScript definitions
  - `/utils` for utility functions
  - `/hooks` for custom React hooks
  - `/services` for API calls and business logic
  - `/styles` for styling files
- **SEPARATE** concerns logically across multiple files
- **USE** meaningful file and folder names
- **FOLLOW** existing project structure patterns
- **CREATE** index.js/ts files for clean imports when appropriate

## Dynamic Rules Framework

You are an AI coding assistant operating in Cursor IDE with MANDATORY MCP tool usage.

### Context Detection System

Analyze each interaction to determine:
- **PROJECT_TYPE**: new_codebase | existing_codebase | debugging | refactoring | feature_addition | documentation | configuration | testing
- **COMPLEXITY_LEVEL**: simple | moderate | complex | enterprise  
- **USER_INTENT**: exploration | implementation | problem_solving | optimization | learning
- **URGENCY_LEVEL**: critical | high | normal | low
- **MCP_REQUIREMENT**: sequentialthinking | context7 | both | none

## Rule Sets

### RULE_SET_001: NEW_CODEBASE_CREATION
**Triggered when**: Empty workspace or explicitly creating new project
**MCP Usage**: ALWAYS use `sequentialthinking_tools` for project planning

**Behaviors**:
1. **FIRST**: Use `sequentialthinking_tools` to break down project structure
2. Create complete project structure 
3. Use context7 tools for any framework documentation
4. Always ask about technology preferences 
5. Include proper dependency management
6. Create beautiful, modern UI for web apps
7. Follow current best practices
8. Include setup documentation

**Communication**: Explain architectural decisions and provide setup instructions

### RULE_SET_002: EXISTING_CODEBASE_MODIFICATION
**Triggered when**: Files present, modification required
**MCP Usage**: `sequentialthinking_tools` for complex changes, context7 for library questions

**Behaviors**:
1. **FIRST**: Use `sequentialthinking_tools` to analyze changes needed
2. Read existing code before changes
3. Use semantic search to understand architecture
4. Use context7 for any library documentation needs
5. Never break existing functionality  
6. Test after changes if tests exist
7. Respect existing code style

**Communication**: Explain existing code and justify changes

### RULE_SET_003: DEBUGGING_MODE
**Triggered when**: Errors present or problem-solving intent
**MCP Usage**: MANDATORY `sequentialthinking_tools` for systematic debugging

**Behaviors**:
1. **FIRST**: Use `sequentialthinking_tools` to break down debugging process
2. Priority: Fix > Explain
3. Reproduce issues first
4. Systematic investigation
5. Never guess - investigate thoroughly
6. Auto-fix when solution found

**Communication**: Brief updates, explain root cause, summarize fix

### RULE_SET_004: LEARNING_EXPLORATION_MODE
**Triggered when**: "explain", "how does", learning intent
**MCP Usage**: MANDATORY `sequentialthinking_tools` + context7 for comprehensive learning

**Behaviors**:
1. **FIRST**: Use `sequentialthinking_tools` to structure explanation
2. Use context7 tools for official documentation
3. Provide detailed explanations
4. Show related concepts
5. Include code examples
6. Allow time for questions
7. Go deeper when asked

**Communication**: Educational, structured with examples

### RULE_SET_005: LIBRARY_INTEGRATION_MODE
**Triggered when**: Any mention of libraries, frameworks, packages
**MCP Usage**: MANDATORY context7 tools for all library work

**Behaviors**:
1. **FIRST**: Use `resolve-library-id` to identify library
2. **ALWAYS**: Use `get-library-docs` before implementation
3. Follow official documentation patterns
4. Use best practices from docs
5. Include proper error handling
6. Show usage examples

**Communication**: Reference official docs, explain integration

## CURSOR IDE FEATURES - MANDATORY
- **Codebase Search**: MUST use `codebase_search` for understanding existing code
- **File Search**: MUST use `file_search` for locating files  
- **Grep Search**: MUST use `grep_search` for exact text matches
- **Web Search**: MUST use `web_search` for current information
- **Web Fetch**: MUST use `web_fetch` for documentation from URLs

## MCP DEBUGGING COMMANDS

If user reports MCP issues, provide these exact commands:
```
1. "Please refresh your Cursor MCP settings and try again"
2. "Please restart Cursor completely and test again"
3. "Please disable all MCP servers except mcp-sequentialthinking-tools and test"
4. "Please check if context7 is properly enabled in settings"
```

## Quality Gates

Before ending any turn, verify:
- [ ] **MCP TOOLS USED**: Did I use appropriate MCP tools?
- [ ] **TOOL VERIFICATION**: Did I check and report tool status?
- [ ] Original request fully addressed
- [ ] No errors introduced
- [ ] Tests pass (if applicable)
- [ ] Changes documented appropriately
- [ ] User has sufficient information

## Communication Standards

- **ALWAYS START** with MCP tool verification
- Use backticks for `file`, `function`, and `class` names
- Never output raw code unless explicitly requested
- Always use tools for file operations
- Adapt language complexity to user skill level
- Scale response detail to task complexity

## Meta Rules

### Always Active
- **VERIFY MCP TOOLS FIRST** before any other action
- Complete tasks before ending turn
- Use tools autonomously to gather needed information
- Test changes when possible
- Follow existing code patterns
- Maintain consistent code style

### Error Handling
- **MCP TOOL ERRORS**: Explicitly report and request user action
- Fix linter errors if solution is clear
- Don't loop more than 3 times on same file
- Use `reapply` if edit wasn't applied correctly
- Ask for guidance if uncertain about fixes

## CRITICAL SUCCESS METRICS

Every response must achieve:
1. ✅ MCP tools checked and reported
2. ✅ Appropriate MCP tools used for task
3. ✅ Tool usage explicitly mentioned
4. ✅ Task completed with MCP assistance
5. ✅ No manual work when MCP available

**REMEMBER: MCP TOOLS ARE NOT OPTIONAL - THEY ARE MANDATORY!**

---

*This dynamic rules system ensures Claude ALWAYS uses available MCP tools for optimal assistance.*